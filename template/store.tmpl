{{"//nolint"}}
{{"package cacheme"}}

import (
        "time"
        "bytes"
	"text/template"
	"context"
	"errors"
	"fmt"
	"strconv"

	"github.com/go-redis/redis/v8"
	cacheme "github.com/Yiling-J/cacheme-go"
	{{range .Imports}}
	"{{.}}"
	{{end}}
)

const (
	Hit  = "HIT"
	Miss = "MISS"
	Fetch     = "FETCH"
)

func init() {
{{ range $index, $store := .Stores}}
   {{if $store.VersionInfo.IsString}}
   {{.Name}}CacheStore.version = schema.Stores[{{$index}}].Version.(string)
   {{else if $store.VersionInfo.IsInt}}
   {{.Name}}CacheStore.version = strconv.Itoa(schema.Stores[{{$index}}].Version.(int))
   {{else}}
   {{.Name}}CacheStore.versionFunc = schema.Stores[{{$index}}].Version.(func() string)
   {{end}}
{{end}}
}

type Client struct {
     	{{range .Stores}}
	{{ $NodeName := .Name | FirstLower  }}
	{{.Name}}CacheStore *{{$NodeName}}Cache
	{{end}}
	redis cacheme.RedisClient
	cluster bool
	logger  cacheme.Logger
}

func (c *Client) Redis() cacheme.RedisClient {
	return c.redis
}

func (c *Client) SetLogger(l cacheme.Logger) {
	c.logger = l
}

func New(redis cacheme.RedisClient) *Client {
     client := &Client{redis: redis}
     {{range .Stores}}
     client.{{.Name}}CacheStore = {{.Name}}CacheStore.Clone(client.redis)
     client.{{.Name}}CacheStore.SetClient(client)
     {{end}}
     client.logger = &cacheme.NOPLogger{}
     return client
}

func NewCluster(redis cacheme.RedisClient) *Client {
     client := &Client{redis: redis, cluster: true}
     {{range .Stores}}
     client.{{.Name}}CacheStore = {{.Name}}CacheStore.Clone(client.redis)
     client.{{.Name}}CacheStore.SetClient(client)
     {{end}}
     client.logger = &cacheme.NOPLogger{}
     return client
}

func (c *Client) NewPipeline() *cacheme.CachePipeline {
	return cacheme.NewPipeline(c.redis)

}

{{ $Prefix := .Prefix  }}

{{range .Stores}}

{{ $NodeName := .Name | FirstLower  }}
type {{$NodeName}}Cache struct {
     Fetch func(ctx context.Context, {{ range $index, $element := .Vars}}{{if $index}},{{end}}{{.}} string{{end}}) ({{.Type}}, error)
     tag string
     memo *cacheme.RedisMemoLock
     client *Client
     version string
     versionFunc func() string
}

type {{.Name}}Promise struct {
	executed     chan bool
	redisPromise *redis.StringCmd
	result       {{.Type}}
	error        error
	store        *{{$NodeName}}Cache
	ctx          context.Context
}

func (p *{{.Name}}Promise) WaitExecute(cp *cacheme.CachePipeline, key string, {{ range $index, $element := .Vars}}{{if $index}},{{end}}{{.}} string{{end}}) {
	defer cp.Wg.Done()
	var t {{.Type}}
	memo := p.store.memo

	<-cp.Executed
	value, err := p.redisPromise.Bytes()
	if err == nil {
	        p.store.client.logger.Log(p.store.tag, key, Hit)
		err = cacheme.Unmarshal(value, &t)
		p.result, p.error = t, err
		return
	}

	resourceLock, err := memo.Lock(p.ctx, key)
	if err != nil {
		p.error = err
		return
	}
	p.store.client.logger.Log(p.store.tag, key, Miss)

	if resourceLock {
		p.store.client.logger.Log(p.store.tag, key, Fetch)
		value, err := p.store.Fetch(
		p.ctx,
		{{ range $index, $element := .Vars}}{{if $index}},{{end}}{{.}}{{end}})
		if err != nil {
			p.error = err
			return
		}
		p.result = value
		packed, err := cacheme.Marshal(value)
		if err == nil {
			memo.SetCache(p.ctx, key, packed, time.Millisecond * {{.TTL.Milliseconds}})
			memo.AddGroup(p.ctx, p.store.Group(), key)
		}
		p.error = err
		return
	}

	var res []byte
	if {{.Singleflight}} {
	   res, err = memo.WaitSingle(p.ctx, key)
	} else {
	  res, err = memo.Wait(p.ctx, key)
	}
	if err == nil {
		err = cacheme.Unmarshal(res, &t)
	}
	p.result, p.error = t, err
}

func (p *{{.Name}}Promise) Result() ({{.Type}}, error) {
	return p.result, p.error
}

var {{.Name}}CacheStore = &{{$NodeName}}Cache{tag: "{{.Name}}"}

func (s *{{$NodeName}}Cache) SetClient(c *Client) {
     s.client = c
}

func (s *{{$NodeName}}Cache) Clone(r cacheme.RedisClient) *{{$NodeName}}Cache {
     value := *s
     new := &value
     lock, err := cacheme.NewRedisMemoLock(
     	   context.TODO(), "cacheme", r, s.tag, 5*time.Second,
     )
     if err != nil {
     	fmt.Println(err)
     }
     new.memo = lock

     return new
}

func (s *{{$NodeName}}Cache) Version() string {
     if s.versionFunc != nil {
     	return s.versionFunc()
     }
     return s.version
}

func (s *{{$NodeName}}Cache) KeyTemplate() string {
     return "{{.Key}}" + ":v" + s.Version()
}

func (s *{{$NodeName}}Cache) Key(m map[string]string) (string, error) {
     t := template.Must(template.New("").Parse(s.KeyTemplate()))
     t = t.Option("missingkey=zero")
     var tpl bytes.Buffer
     err := t.Execute(&tpl, m)
     return tpl.String(), err
}

func (s *{{$NodeName}}Cache) Group() string {
	return "{{$Prefix}}" + ":group:" + s.tag + ":v" + s.Version()
}

func (s *{{$NodeName}}Cache) versionedGroup(v string) string {
	return "{{$Prefix}}" + ":group:" + s.tag + ":v" + v
}

func (s *{{$NodeName}}Cache) AddMemoLock() error {
     lock, err := cacheme.NewRedisMemoLock(context.TODO(), "{{$Prefix}}", s.client.redis, s.tag, 5*time.Second)
     if err != nil {
     	return err
     }

     s.memo = lock
     return nil
}

func (s *{{$NodeName}}Cache) Initialized() bool {
	return s.Fetch != nil
}

func (s *{{$NodeName}}Cache) Tag() string {
	return s.tag
}

func (s *{{$NodeName}}Cache) GetP(ctx context.Context, pp *cacheme.CachePipeline, {{ range $index, $element := .Vars}}{{if $index}},{{end}}{{.}} string{{end}}) (*{{.Name}}Promise, error) {
	params := make(map[string]string)

	{{range .Vars}}
	params["{{.}}"] = {{.}}
	{{end}}


	key, err := s.Key(params)
	if err != nil {
		return nil, err
	}

	cacheme := s.memo

	promise := &{{.Name}}Promise{
		executed: pp.Executed,
		ctx:      ctx,
		store:    s,
	}

	wait := cacheme.GetCachedP(ctx, pp.Pipeline, key)
	promise.redisPromise = wait
	pp.Wg.Add(1)
	go promise.WaitExecute(
	pp, key, {{ range $index, $element := .Vars}}{{if $index}},{{end}}{{.}}{{end}})
	return promise, nil
}

func (s *{{$NodeName}}Cache) Get(ctx context.Context, {{ range $index, $element := .Vars}}{{if $index}},{{end}}{{.}} string{{end}}) ({{.Type}}, error) {

     params := make(map[string]string)
     {{range .Vars}}
     params["{{.}}"] = {{.}}
     {{end}}

     var t {{.Type}}

     key, err := s.Key(params)
     if err != nil {
     	return t, err
     }


	if true {
		data, err, _ := s.memo.SingleGroup().Do(key, func() (interface{}, error) {
			return s.get(ctx, {{ range $index, $element := .Vars}}{{if $index}},{{end}}{{.}}{{end}})
		})
		return data.({{.Type}}), err
	}
	return s.get(ctx, {{ range $index, $element := .Vars}}{{if $index}},{{end}}{{.}}{{end}})
}

func (s *{{$NodeName}}Cache) get(ctx context.Context, {{ range $index, $element := .Vars}}{{if $index}},{{end}}{{.}} string{{end}}) ({{.Type}}, error) {
     params := make(map[string]string)
     {{range .Vars}}
     params["{{.}}"] = {{.}}
     {{end}}

     var t {{.Type}}

     key, err := s.Key(params)
     if err != nil {
     	return t, err
     }

     memo := s.memo
     var res []byte
     
     res, err = memo.GetCached(ctx, key)
     if err == nil {
	s.client.logger.Log(s.tag, key, Hit)
	err = cacheme.Unmarshal(res, &t)
	return t, err
     }

     if err != redis.Nil {
	return t, errors.New("")
     }
     s.client.logger.Log(s.tag, key, Miss)

	resourceLock, err := memo.Lock(ctx, key)
	if err != nil {
		return t, err
	}

     if resourceLock {
     	s.client.logger.Log(s.tag, key, Fetch)
	value, err := s.Fetch(ctx, {{ range $index, $element := .Vars}}{{if $index}},{{end}}{{.}}{{end}})
	if err != nil {
	   return value, err
	}
	packed, err := cacheme.Marshal(value)
	if err == nil {
		memo.SetCache(ctx, key, packed, time.Millisecond * {{.TTL.Milliseconds}})
		memo.AddGroup(ctx, s.Group(), key)
	}
	return value, err
     }

     res, err = memo.Wait(ctx, key)
       
     if err == nil {
	err = cacheme.Unmarshal(res, &t)
	return t, err
     }
     return t, err
}

func (s *{{$NodeName}}Cache) Update(ctx context.Context, {{ range $index, $element := .Vars}}{{if $index}},{{end}}{{.}} string{{end}}) error {

     params := make(map[string]string)
     {{range .Vars}}
     params["{{.}}"] = {{.}}
     {{end}}

     key, err := s.Key(params)
     if err != nil {
     	return err
     }
     
     value, err := s.Fetch(ctx, {{ range $index, $element := .Vars}}{{if $index}},{{end}}{{.}}{{end}})
     if err != nil {
     	return err
     }
     packed, err := cacheme.Marshal(value)
     if err == nil {
	s.memo.SetCache(ctx, key, packed, time.Millisecond * {{.TTL.Milliseconds}})
	s.memo.AddGroup(ctx, s.Group(), key)
    }
    return err
}

func (s *{{$NodeName}}Cache) Invalid(ctx context.Context, {{ range $index, $element := .Vars}}{{if $index}},{{end}}{{.}} string{{end}}) error {

     params := make(map[string]string)
     {{range .Vars}}
     params["{{.}}"] = {{.}}
     {{end}}

     key, err := s.Key(params)
     if err != nil {
     	return err
     }
     return  s.memo.DeleteCache(ctx, key)

}

func (s *{{$NodeName}}Cache) InvalidAll(ctx context.Context, version string) error {
     group := s.versionedGroup(version)
     if s.client.cluster {
     	return cacheme.InvalidAllCluster(ctx, group, s.client.redis)
     }
     return cacheme.InvalidAll(ctx, group, s.client.redis)

}

{{end}}