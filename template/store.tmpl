{{"//nolint"}}
{{"package cacheme"}}

import (
        "time"
        "bytes"
	"text/template"
	"context"
	"errors"
	"fmt"
	"strings"
	"sort"

	"github.com/go-redis/redis/v8"
	cacheme "github.com/Yiling-J/cacheme-go"
	{{range .Imports}}
	"{{.}}"
	{{end}}
)

const (
	Hit  = "HIT"
	Miss = "MISS"
	Fetch     = "FETCH"
)

func init() {
{{ range $index, $store := .Stores}}
   {{if $store.VersionInfo.IsString}}
   {{.Name}}CacheStore.version = schema.Stores[{{$index}}].Version.(string)
   {{else if $store.VersionInfo.IsInt}}
   {{.Name}}CacheStore.version = strconv.Itoa(schema.Stores[{{$index}}].Version.(int))
   {{else}}
   {{.Name}}CacheStore.versionFunc = schema.Stores[{{$index}}].Version.(func() string)
   {{end}}
{{end}}
}

type Client struct {
     	{{range .Stores}}
	{{ $NodeName := .Name | FirstLower  }}
	{{.Name}}CacheStore *{{$NodeName}}Cache
	{{end}}
	redis cacheme.RedisClient
	cluster bool
	logger  cacheme.Logger
}

func (c *Client) Redis() cacheme.RedisClient {
	return c.redis
}

func (c *Client) SetLogger(l cacheme.Logger) {
	c.logger = l
}

func New(redis cacheme.RedisClient) *Client {
     client := &Client{redis: redis}
     {{range .Stores}}
     client.{{.Name}}CacheStore = {{.Name}}CacheStore.Clone(client.redis)
     client.{{.Name}}CacheStore.SetClient(client)
     {{end}}
     client.logger = &cacheme.NOPLogger{}
     return client
}

func NewCluster(redis cacheme.RedisClient) *Client {
     client := &Client{redis: redis, cluster: true}
     {{range .Stores}}
     client.{{.Name}}CacheStore = {{.Name}}CacheStore.Clone(client.redis)
     client.{{.Name}}CacheStore.SetClient(client)
     {{end}}
     client.logger = &cacheme.NOPLogger{}
     return client
}

func (c *Client) NewPipeline() *cacheme.CachePipeline {
	return cacheme.NewPipeline(c.redis)

}

{{ $Prefix := .Prefix  }}

{{range .Stores}}

{{ $NodeName := .Name | FirstLower  }}
type {{$NodeName}}Cache struct {
     Fetch func(ctx context.Context, {{ range $index, $element := .Vars}}{{if $index}},{{end}}{{.}} string{{end}}) ({{.Type}}, error)
     tag string
     memo *cacheme.RedisMemoLock
     client *Client
     version string
     versionFunc func() string
}

type {{.Name}}Promise struct {
	executed     chan bool
	redisPromise *redis.StringCmd
	result       {{.Type}}
	error        error
	store        *{{$NodeName}}Cache
	ctx          context.Context
}

func (p *{{.Name}}Promise) WaitExecute(cp *cacheme.CachePipeline, key string, {{ range $index, $element := .Vars}}{{if $index}},{{end}}{{.}} string{{end}}) {
	defer cp.Wg.Done()
	var t {{.Type}}
	memo := p.store.memo

	<-cp.Executed
	value, err := p.redisPromise.Bytes()
	if err == nil {
	        p.store.client.logger.Log(p.store.tag, key, Hit)
		err = cacheme.Unmarshal(value, &t)
		p.result, p.error = t, err
		return
	}

	resourceLock, err := memo.Lock(p.ctx, key)
	if err != nil {
		p.error = err
		return
	}
	p.store.client.logger.Log(p.store.tag, key, Miss)

	if resourceLock {
		p.store.client.logger.Log(p.store.tag, key, Fetch)
		value, err := p.store.Fetch(
		p.ctx,
		{{ range $index, $element := .Vars}}{{if $index}},{{end}}{{.}}{{end}})
		if err != nil {
			p.error = err
			return
		}
		p.result = value
		packed, err := cacheme.Marshal(value)
		if err == nil {
			memo.SetCache(p.ctx, key, packed, time.Millisecond * {{.TTL.Milliseconds}})
			memo.AddGroup(p.ctx, p.store.Group(), key)
		}
		p.error = err
		return
	}

	var res []byte
	if {{.Singleflight}} {
	   res, err = memo.WaitSingle(p.ctx, key)
	} else {
	  res, err = memo.Wait(p.ctx, key)
	}
	if err == nil {
		err = cacheme.Unmarshal(res, &t)
	}
	p.result, p.error = t, err
}

func (p *{{.Name}}Promise) Result() ({{.Type}}, error) {
	return p.result, p.error
}

var {{.Name}}CacheStore = &{{$NodeName}}Cache{tag: "{{.Name}}"}

func (s *{{$NodeName}}Cache) SetClient(c *Client) {
     s.client = c
}

func (s *{{$NodeName}}Cache) Clone(r cacheme.RedisClient) *{{$NodeName}}Cache {
     value := *s
     new := &value
     lock, err := cacheme.NewRedisMemoLock(
     	   context.TODO(), "cacheme", r, s.tag, 5*time.Second,
     )
     if err != nil {
     	fmt.Println(err)
     }
     new.memo = lock

     return new
}

func (s *{{$NodeName}}Cache) Version() string {
     if s.versionFunc != nil {
     	return s.versionFunc()
     }
     return s.version
}

func (s *{{$NodeName}}Cache) KeyTemplate() string {
     return "{{.Key}}" + ":v" + s.Version()
}

func (s *{{$NodeName}}Cache) Key(p *{{$NodeName}}Param) (string, error) {
     t := template.Must(template.New("").Parse(s.KeyTemplate()))
     t = t.Option("missingkey=zero")
     var tpl bytes.Buffer
     err := t.Execute(&tpl, p)
     return tpl.String(), err
}

func (s *{{$NodeName}}Cache) Group() string {
	return "{{$Prefix}}" + ":meta:group:" + s.tag + ":v" + s.Version()
}

func (s *{{$NodeName}}Cache) versionedGroup(v string) string {
	return "{{$Prefix}}" + ":meta:group:" + s.tag + ":v" + v
}

func (s *{{$NodeName}}Cache) AddMemoLock() error {
     lock, err := cacheme.NewRedisMemoLock(context.TODO(), "{{$Prefix}}", s.client.redis, s.tag, 5*time.Second)
     if err != nil {
     	return err
     }

     s.memo = lock
     return nil
}

func (s *{{$NodeName}}Cache) Initialized() bool {
	return s.Fetch != nil
}

func (s *{{$NodeName}}Cache) Tag() string {
	return s.tag
}

func (s *{{$NodeName}}Cache) GetP(ctx context.Context, pp *cacheme.CachePipeline, {{ range $index, $element := .Vars}}{{if $index}},{{end}}{{.}} string{{end}}) (*{{.Name}}Promise, error) {
     	param := &{{$NodeName}}Param{}
     	{{range .Vars}}
     	param.{{.}} = {{.}}
     	{{end}}

	key, err := s.Key(param)
	if err != nil {
		return nil, err
	}

	cacheme := s.memo

	promise := &{{.Name}}Promise{
		executed: pp.Executed,
		ctx:      ctx,
		store:    s,
	}

	wait := cacheme.GetCachedP(ctx, pp.Pipeline, key)
	promise.redisPromise = wait
	pp.Wg.Add(1)
	go promise.WaitExecute(
	pp, key, {{ range $index, $element := .Vars}}{{if $index}},{{end}}{{.}}{{end}})
	return promise, nil
}

func (s *{{$NodeName}}Cache) Get(ctx context.Context, {{ range $index, $element := .Vars}}{{if $index}},{{end}}{{.}} string{{end}}) ({{.Type}}, error) {

     param := &{{$NodeName}}Param{}
     {{range .Vars}}
     param.{{.}} = {{.}}
     {{end}}

     var t {{.Type}}

     key, err := s.Key(param)
     if err != nil {
     	return t, err
     }


	if {{.Singleflight}} {
		data, err, _ := s.memo.SingleGroup().Do(key, func() (interface{}, error) {
			return s.get(ctx, {{ range $index, $element := .Vars}}{{if $index}},{{end}}{{.}}{{end}})
		})
		return data.({{.Type}}), err
	}
	return s.get(ctx, {{ range $index, $element := .Vars}}{{if $index}},{{end}}{{.}}{{end}})
}

type {{$NodeName}}Param struct {
     {{range .Vars}}
     {{.}} string
     {{end}}
}

func (p *{{$NodeName}}Param) pid() string {
	var id string
	{{ range $index, $element := .Vars}}
	{{if $index}}
	id = id + ":" + p.{{$element}}
	{{else}}
	id = id + p.{{$element}}
	{{end}}
	{{end}}
	return id
}

type {{.Name}}MultiGetter struct {
	store *{{$NodeName}}Cache
	keys  []{{$NodeName}}Param
}

type {{$NodeName}}QuerySet struct {
	keys    []string
	results map[string]{{.Type}}
}

func (q *{{$NodeName}}QuerySet) Get({{ range $index, $element := .Vars}}{{if $index}},{{end}}{{.}} string{{end}}) ({{.Type}}, error) {
	param := {{$NodeName}}Param{
	     {{range .Vars}}
     	     {{.}}: {{.}},
     	     {{end}}
	}
	v, ok := q.results[param.pid()]
	if !ok {return v, errors.New("not found")}
	return v, nil
}

func (q *{{$NodeName}}QuerySet) GetSlice() []{{.Type}} {
	var results []{{.Type}}
	for _, k := range q.keys {
		results = append(results, q.results[k])
	}
	return results
}

func (s *{{$NodeName}}Cache) MGetter() *{{.Name}}MultiGetter {
	return &{{.Name}}MultiGetter{
		store: s,
		keys:  []{{$NodeName}}Param{},
	}
}

func (g *{{.Name}}MultiGetter) GetM({{ range $index, $element := .Vars}}{{if $index}},{{end}}{{.}} string{{end}}) *{{.Name}}MultiGetter {
	g.keys = append(g.keys, {{$NodeName}}Param{{"{"}}{{ range $index, $element := .Vars}}{{if $index}},{{end}}{{.}}:{{.}}{{end}}{{"}"}})
	return g
}

func (g *{{.Name}}MultiGetter) Do(ctx context.Context) (*{{$NodeName}}QuerySet, error) {
     qs := &{{$NodeName}}QuerySet{}
     var keys []string
     for _, k := range g.keys {
     	 pid := k.pid()
	 qs.keys = append(qs.keys, pid)
     	 keys = append(keys, pid)
     }
	if {{.Singleflight}} {
		sort.Strings(keys)
		group := strings.Join(keys, ":")
		data, err, _ := g.store.memo.SingleGroup().Do(group, func() (interface{}, error) {
			return g.pipeDo(ctx)
		})
		qs.results = data.(map[string]{{.Type}})
		return qs, err
	}
	data, err := g.pipeDo(ctx)
	qs.results = data
	return qs, err
}

func (g *{{.Name}}MultiGetter) pipeDo(ctx context.Context) (map[string]{{.Type}}, error) {
	pipeline := cacheme.NewPipeline(g.store.client.Redis())
	ps := make(map[string]*{{.Name}}Promise)
	for _, k := range g.keys {
	       	pid := k.pid()
		if _, ok := ps[pid]; ok {
			continue
		}
		promise, err := g.store.GetP(ctx, pipeline, {{ range $index, $element := .Vars}}{{if $index}},{{end}}k.{{.}}{{end}})
		if err != nil {
			return nil, err
		}
		ps[pid] = promise
	}

	err := pipeline.Execute(ctx)
	if err != nil {
		return nil, err
	}

	results := make(map[string]{{.Type}})
	for k, p := range ps {
		r, err := p.Result()
		if err != nil {
			return nil, err
		}
		results[k] = r
	}
	return results, nil
}

func (s *{{$NodeName}}Cache) GetM({{ range $index, $element := .Vars}}{{if $index}},{{end}}{{.}} string{{end}}) *{{.Name}}MultiGetter {
	return &{{.Name}}MultiGetter{
		store: s,
		keys:  []{{$NodeName}}Param{{"{{"}}{{ range $index, $element := .Vars}}{{if $index}},{{end}}{{.}}:{{.}}{{end}}{{"}}"}},
	}
}


func (s *{{$NodeName}}Cache) get(ctx context.Context, {{ range $index, $element := .Vars}}{{if $index}},{{end}}{{.}} string{{end}}) ({{.Type}}, error) {
     param := &{{$NodeName}}Param{}
     {{range .Vars}}
     param.{{.}} = {{.}}
     {{end}}

     var t {{.Type}}

     key, err := s.Key(param)
     if err != nil {
     	return t, err
     }

     memo := s.memo
     var res []byte
     
     res, err = memo.GetCached(ctx, key)
     if err == nil {
	s.client.logger.Log(s.tag, key, Hit)
	err = cacheme.Unmarshal(res, &t)
	return t, err
     }

     if err != redis.Nil {
	return t, errors.New("")
     }
     s.client.logger.Log(s.tag, key, Miss)

	resourceLock, err := memo.Lock(ctx, key)
	if err != nil {
		return t, err
	}

     if resourceLock {
     	s.client.logger.Log(s.tag, key, Fetch)
	value, err := s.Fetch(ctx, {{ range $index, $element := .Vars}}{{if $index}},{{end}}{{.}}{{end}})
	if err != nil {
	   return value, err
	}
	packed, err := cacheme.Marshal(value)
	if err == nil {
		memo.SetCache(ctx, key, packed, time.Millisecond * {{.TTL.Milliseconds}})
		memo.AddGroup(ctx, s.Group(), key)
	}
	return value, err
     }

     res, err = memo.Wait(ctx, key)
       
     if err == nil {
	err = cacheme.Unmarshal(res, &t)
	return t, err
     }
     return t, err
}

func (s *{{$NodeName}}Cache) Update(ctx context.Context, {{ range $index, $element := .Vars}}{{if $index}},{{end}}{{.}} string{{end}}) error {

     param := &{{$NodeName}}Param{}
     {{range .Vars}}
     param.{{.}} = {{.}}
     {{end}}

     key, err := s.Key(param)
     if err != nil {
     	return err
     }
     
     value, err := s.Fetch(ctx, {{ range $index, $element := .Vars}}{{if $index}},{{end}}{{.}}{{end}})
     if err != nil {
     	return err
     }
     packed, err := cacheme.Marshal(value)
     if err == nil {
	s.memo.SetCache(ctx, key, packed, time.Millisecond * {{.TTL.Milliseconds}})
	s.memo.AddGroup(ctx, s.Group(), key)
    }
    return err
}

func (s *{{$NodeName}}Cache) Invalid(ctx context.Context, {{ range $index, $element := .Vars}}{{if $index}},{{end}}{{.}} string{{end}}) error {

     param := &{{$NodeName}}Param{}
     {{range .Vars}}
     param.{{.}} = {{.}}
     {{end}}

     key, err := s.Key(param)
     if err != nil {
     	return err
     }
     return  s.memo.DeleteCache(ctx, key)

}

func (s *{{$NodeName}}Cache) InvalidAll(ctx context.Context, version string) error {
     group := s.versionedGroup(version)
     if s.client.cluster {
     	return cacheme.InvalidAllCluster(ctx, group, s.client.redis)
     }
     return cacheme.InvalidAll(ctx, group, s.client.redis)

}

{{end}}
