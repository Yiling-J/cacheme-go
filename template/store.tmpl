// Code generated by cacheme, DO NOT EDIT.
{{"package store"}}

import (
        "time"
        "bytes"
	"text/template"
	"context"
	"errors"
	"fmt"
	"strings"
	"sort"

	"github.com/go-redis/redis/v8"
	cacheme "github.com/Yiling-J/cacheme-go"
	{{range .Imports}}
	"{{.}}"
	{{end}}
)

{{ $Prefix := .Prefix  }}

{{range .Stores}}

{{$Name := .Name}}
{{$NameH := .Name | FirstLower}}
// {{$Name}}Cache is the store for {{$Name}}
type {{$Name}}Cache struct {
     Fetch func(ctx context.Context, {{ range $index, $element := .Vars}}{{if $index}},{{end}}{{.}} string{{end}}) ({{.Type}}, error)
     tag string
     memo *cacheme.RedisMemoLock
     client *Client
     versionString string
     versionFunc func() string
     singleflight bool
     metadata bool
}

// {{$Name}}Promise is the promise for {{$Name}}
type {{$Name}}Promise struct {
	executed     chan bool
	redisPromise *redis.StringCmd
	result       {{.Type}}
	error        error
	store        *{{$Name}}Cache
	ctx          context.Context
}

func (p *{{$Name}}Promise) waitExecute(cp *cacheme.CachePipeline, key string, {{ range $index, $element := .Vars}}{{if $index}},{{end}}{{.}} string{{end}}) {
	defer cp.Wg.Done()
	var t {{.Type}}
	memo := p.store.memo

	<-cp.Executed
	value, err := p.redisPromise.Bytes()
	if err == nil {
	        p.store.client.logger.Log(p.store.tag, key, Hit)
		err = cacheme.Unmarshal(value, &t)
		p.result, p.error = t, err
		return
	}

	resourceLock, err := memo.Lock(p.ctx, key)
	if err != nil {
		p.error = err
		return
	}
	p.store.client.logger.Log(p.store.tag, key, Miss)

	if resourceLock {
		p.store.client.logger.Log(p.store.tag, key, Fetch)
		value, err := p.store.Fetch(
		p.ctx,
		{{ range $index, $element := .Vars}}{{if $index}},{{end}}{{.}}{{end}})
		if err != nil {
			p.error = err
			return
		}
		p.result = value
		packed, err := cacheme.Marshal(value)
		if err == nil {
			memo.SetCache(p.ctx, key, packed, time.Millisecond * {{.TTL.Milliseconds}})
			if p.store.metadata {
			memo.AddGroup(p.ctx, p.store.group(), key)
			}
		}
		p.error = err
		return
	}

	var res []byte
	if p.store.singleflight {
	   res, err = memo.WaitSingle(p.ctx, key)
	} else {
	  res, err = memo.Wait(p.ctx, key)
	}
	if err == nil {
		err = cacheme.Unmarshal(res, &t)
	}
	p.result, p.error = t, err
}

// Result return promise result.
func (p *{{$Name}}Promise) Result() ({{.Type}}, error) {
	return p.result, p.error
}

func (s *{{$Name}}Cache) setClient(c *Client) {
     s.client = c
}

func (s *{{$Name}}Cache) clone(r cacheme.RedisClient) *{{$Name}}Cache {
     value := *s
     new := &value
     lock, err := cacheme.NewRedisMemoLock(
     	   context.TODO(), "cacheme", r, s.tag, 5*time.Second,
     )
     if err != nil {
     	fmt.Println(err)
     }
     new.memo = lock

     return new
}

func (s *{{$Name}}Cache) version() string {
     if s.versionFunc != nil {
     	return s.versionFunc()
     }
     return s.versionString
}

func (s *{{$Name}}Cache) keyTemplate() string {
     return "{{.Key}}" + ":v" + s.version()
}

func (s *{{$Name}}Cache) key(p *{{$NameH}}Param) (string, error) {
     t := template.Must(template.New("").Parse(s.keyTemplate()))
     t = t.Option("missingkey=zero")
     var tpl bytes.Buffer
     err := t.Execute(&tpl, p)
     return tpl.String(), err
}

func (s *{{$Name}}Cache) group() string {
	return "{{$Prefix}}" + ":group:" + s.tag + ":v" + s.version()
}

func (s *{{$Name}}Cache) versionedGroup(v string) string {
	return "{{$Prefix}}" + ":group:" + s.tag + ":v" + v
}

func (s *{{$Name}}Cache) addMemoLock() error {
     lock, err := cacheme.NewRedisMemoLock(context.TODO(), "{{$Prefix}}", s.client.redis, s.tag, 5*time.Second)
     if err != nil {
     	return err
     }

     s.memo = lock
     return nil
}

func (s *{{$Name}}Cache) initialized() bool {
	return s.Fetch != nil
}

// GetP return a pipeline getter.
func (s *{{$Name}}Cache) GetP(ctx context.Context, pp *cacheme.CachePipeline, {{ range $index, $element := .Vars}}{{if $index}},{{end}}{{.}} string{{end}}) (*{{$Name}}Promise, error) {
     	param := &{{$NameH}}Param{}
     	{{range .Vars}}
     	param.{{.}} = {{.}}
     	{{end}}

	key, err := s.key(param)
	if err != nil {
		return nil, err
	}

	cacheme := s.memo

	promise := &{{$Name}}Promise{
		executed: pp.Executed,
		ctx:      ctx,
		store:    s,
	}

	wait := cacheme.GetCachedP(ctx, pp.Pipeline, key)
	promise.redisPromise = wait
	pp.Wg.Add(1)
	go promise.waitExecute(
	pp, key, {{ range $index, $element := .Vars}}{{if $index}},{{end}}{{.}}{{end}})
	return promise, nil
}

// Get return result from store.
func (s *{{$Name}}Cache) Get(ctx context.Context, {{ range $index, $element := .Vars}}{{if $index}},{{end}}{{.}} string{{end}}) ({{.Type}}, error) {

     param := &{{$NameH}}Param{}
     {{range .Vars}}
     param.{{.}} = {{.}}
     {{end}}

     var t {{.Type}}

     key, err := s.key(param)
     if err != nil {
     	return t, err
     }


	if s.singleflight {
		data, err, _ := s.memo.SingleGroup().Do(key, func() (interface{}, error) {
			return s.get(ctx, {{ range $index, $element := .Vars}}{{if $index}},{{end}}{{.}}{{end}})
		})
		return data.({{.Type}}), err
	}
	return s.get(ctx, {{ range $index, $element := .Vars}}{{if $index}},{{end}}{{.}}{{end}})
}

type {{$NameH}}Param struct {
     {{range .Vars}}
     {{.}} string
     {{end}}
}

func (p *{{$NameH}}Param) pid() string {
	var id string
	{{ range $index, $element := .Vars}}
	{{if $index}}
	id = id + ":" + p.{{$element}}
	{{else}}
	id = id + p.{{$element}}
	{{end}}
	{{end}}
	return id
}

type {{$Name}}MultiGetter struct {
	store *{{$Name}}Cache
	keys  []{{$NameH}}Param
}

// {{$Name}}QuerySet is a query struct, using Get to get a single element or GetSlice to get all elements.
type {{$Name}}QuerySet struct {
	keys    []string
	results map[string]{{.Type}}
}

// Get return single element for queryset with give params, return error if not found.
func (q *{{$Name}}QuerySet) Get({{ range $index, $element := .Vars}}{{if $index}},{{end}}{{.}} string{{end}}) ({{.Type}}, error) {
	param := {{$NameH}}Param{
	     {{range .Vars}}
     	     {{.}}: {{.}},
     	     {{end}}
	}
	v, ok := q.results[param.pid()]
	if !ok {return v, errors.New("not found")}
	return v, nil
}

// GetSlice return all elements from queryset. Same order as input.
func (q *{{$Name}}QuerySet) GetSlice() []{{.Type}} {
	var results []{{.Type}}
	for _, k := range q.keys {
		results = append(results, q.results[k])
	}
	return results
}

// MGetter return a new multiple getter for current store.
func (s *{{$Name}}Cache) MGetter() *{{.Name}}MultiGetter {
	return &{{.Name}}MultiGetter{
		store: s,
		keys:  []{{$NameH}}Param{},
	}
}

// GetM append a new get promise to getter.
func (g *{{$Name}}MultiGetter) GetM({{ range $index, $element := .Vars}}{{if $index}},{{end}}{{.}} string{{end}}) *{{$Name}}MultiGetter {
	g.keys = append(g.keys, {{$NameH}}Param{{"{"}}{{ range $index, $element := .Vars}}{{if $index}},{{end}}{{.}}:{{.}}{{end}}{{"}"}})
	return g
}

// Do send all requests to redis using pipeline and get results, missing parts will call fetch function.
func (g *{{$Name}}MultiGetter) Do(ctx context.Context) (*{{$Name}}QuerySet, error) {
     qs := &{{$Name}}QuerySet{}
     var keys []string
     for _, k := range g.keys {
     	 pid := k.pid()
	 qs.keys = append(qs.keys, pid)
     	 keys = append(keys, pid)
     }
	if g.store.singleflight {
		sort.Strings(keys)
		group := strings.Join(keys, ":")
		data, err, _ := g.store.memo.SingleGroup().Do(group, func() (interface{}, error) {
			return g.pipeDo(ctx)
		})
		qs.results = data.(map[string]{{.Type}})
		return qs, err
	}
	data, err := g.pipeDo(ctx)
	qs.results = data
	return qs, err
}

func (g *{{$Name}}MultiGetter) pipeDo(ctx context.Context) (map[string]{{.Type}}, error) {
	pipeline := cacheme.NewPipeline(g.store.client.Redis())
	ps := make(map[string]*{{$Name}}Promise)
	for _, k := range g.keys {
	       	pid := k.pid()
		if _, ok := ps[pid]; ok {
			continue
		}
		promise, err := g.store.GetP(ctx, pipeline, {{ range $index, $element := .Vars}}{{if $index}},{{end}}k.{{.}}{{end}})
		if err != nil {
			return nil, err
		}
		ps[pid] = promise
	}

	err := pipeline.Execute(ctx)
	if err != nil {
		return nil, err
	}

	results := make(map[string]{{.Type}})
	for k, p := range ps {
		r, err := p.Result()
		if err != nil {
			return nil, err
		}
		results[k] = r
	}
	return results, nil
}

// GetM append a new get promise to getter.
func (s *{{$Name}}Cache) GetM({{ range $index, $element := .Vars}}{{if $index}},{{end}}{{.}} string{{end}}) *{{$Name}}MultiGetter {
	return &{{$Name}}MultiGetter{
		store: s,
		keys:  []{{$NameH}}Param{{"{{"}}{{ range $index, $element := .Vars}}{{if $index}},{{end}}{{.}}:{{.}}{{end}}{{"}}"}},
	}
}


func (s *{{$Name}}Cache) get(ctx context.Context, {{ range $index, $element := .Vars}}{{if $index}},{{end}}{{.}} string{{end}}) ({{.Type}}, error) {
     param := &{{$NameH}}Param{}
     {{range .Vars}}
     param.{{.}} = {{.}}
     {{end}}

     var t {{.Type}}

     key, err := s.key(param)
     if err != nil {
     	return t, err
     }

     memo := s.memo
     var res []byte

     res, err = memo.GetCached(ctx, key)
     if err == nil {
	s.client.logger.Log(s.tag, key, Hit)
	err = cacheme.Unmarshal(res, &t)
	return t, err
     }

     if err != redis.Nil {
	return t, errors.New("")
     }
     s.client.logger.Log(s.tag, key, Miss)

	resourceLock, err := memo.Lock(ctx, key)
	if err != nil {
		return t, err
	}

     if resourceLock {
     	s.client.logger.Log(s.tag, key, Fetch)
	value, err := s.Fetch(ctx, {{ range $index, $element := .Vars}}{{if $index}},{{end}}{{.}}{{end}})
	if err != nil {
	   return value, err
	}
	packed, err := cacheme.Marshal(value)
	if err == nil {
		memo.SetCache(ctx, key, packed, time.Millisecond * {{.TTL.Milliseconds}})
		if s.metadata {
		memo.AddGroup(ctx, s.group(), key)
		}
	}
	return value, err
     }

     res, err = memo.Wait(ctx, key)

     if err == nil {
	err = cacheme.Unmarshal(res, &t)
	return t, err
     }
     return t, err
}

// Update call fetch function with given params and update Redis.
func (s *{{$Name}}Cache) Update(ctx context.Context, {{ range $index, $element := .Vars}}{{if $index}},{{end}}{{.}} string{{end}}) error {

     param := &{{$NameH}}Param{}
     {{range .Vars}}
     param.{{.}} = {{.}}
     {{end}}

     key, err := s.key(param)
     if err != nil {
     	return err
     }

     value, err := s.Fetch(ctx, {{ range $index, $element := .Vars}}{{if $index}},{{end}}{{.}}{{end}})
     if err != nil {
     	return err
     }
     packed, err := cacheme.Marshal(value)
     if err == nil {
	s.memo.SetCache(ctx, key, packed, time.Millisecond * {{.TTL.Milliseconds}})
	if s.metadata {
	s.memo.AddGroup(ctx, s.group(), key)
	}
    }
    return err
}

// Update remove cache with given params from Redis.
func (s *{{$Name}}Cache) Invalid(ctx context.Context, {{ range $index, $element := .Vars}}{{if $index}},{{end}}{{.}} string{{end}}) error {

     param := &{{$NameH}}Param{}
     {{range .Vars}}
     param.{{.}} = {{.}}
     {{end}}

     key, err := s.key(param)
     if err != nil {
     	return err
     }
     return  s.memo.DeleteCache(ctx, key)

}

// InvalidAll will invalid all caches match provided version from current store.
func (s *{{$Name}}Cache) InvalidAll(ctx context.Context, version string) error {
     group := s.versionedGroup(version)
     if s.client.cluster {
     	return cacheme.InvalidAllCluster(ctx, group, s.client.redis)
     }
     return cacheme.InvalidAll(ctx, group, s.client.redis)

}

{{end}}
